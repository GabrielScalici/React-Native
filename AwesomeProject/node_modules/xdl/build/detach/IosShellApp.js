// Copyright 2015-present 650 Industries. All rights reserved.

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIOSShellAppAsync = undefined;

/**
 * Writes Fabric config to private-shell-app-config.json if necessary. Used by
 * generate-dynamic-macros when building.
 */
let configureShellAppSecretsAsync = (() => {
  var _ref = _asyncToGenerator(function* (args, iosDir) {
    if (!args.privateConfigFile) {
      return;
    }

    (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', [args.privateConfigFile, _path.default.join(iosDir, 'private-shell-app-config.json')]);
  });

  return function configureShellAppSecretsAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

/**
 *  Build the iOS binary from source.
 *  @return the path to the resulting .app
 */


let buildAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (args, iOSRootPath, relativeBuildDestination) {
    let { action, configuration, verbose, type } = args;

    let buildCmd, buildDest, pathToApp;
    if (type === 'simulator') {
      buildDest = _path.default.relative(iOSRootPath, `${relativeBuildDestination}-simulator`);
      buildCmd = `xcodebuild -workspace Exponent.xcworkspace -scheme Exponent -sdk iphonesimulator -configuration ${configuration} -derivedDataPath ${buildDest} CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO ARCHS="i386 x86_64" ONLY_ACTIVE_ARCH=NO | xcpretty`;
      pathToApp = `${buildDest}/Build/Products/${configuration}-iphonesimulator/Exponent.app`;
    } else if (type === 'archive') {
      buildDest = _path.default.relative(iOSRootPath, `${relativeBuildDestination}-archive`);
      buildCmd = `xcodebuild -workspace Exponent.xcworkspace -scheme Exponent -sdk iphoneos -destination generic/platform=iOS -configuration ${configuration} archive -derivedDataPath ${buildDest} -archivePath ${buildDest}/Exponent.xcarchive CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO | xcpretty`;
      pathToApp = `${buildDest}/Exponent.xcarchive/Products/Applications/Exponent.app`;
    }

    if (buildCmd) {
      console.log(`Building shell app under ${buildDest}:\n`);
      console.log(buildCmd);
      if (!verbose) {
        console.log('\nxcodebuild is running. Logging errors only. To see full output, use --verbose 1...');
      }
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)(buildCmd, null, {
        // only stderr
        stdio: verbose ? 'inherit' : ['ignore', 'ignore', 'inherit'],
        cwd: iOSRootPath,
        shell: true
      });

      const artifactLocation = _path.default.join(iOSRootPath, '../shellAppBase-builds', type, configuration);
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/rm', ['-rf', artifactLocation]);
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/mkdir', ['-p', artifactLocation]);

      console.log(`\nFinished building, copying artifact to ${artifactLocation}...`);
      if (type === 'archive') {
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', ['-R', `${buildDest}/Exponent.xcarchive`, artifactLocation]);
      } else if (type === 'simulator') {
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', ['-R', pathToApp, artifactLocation]);
      }
    }
    return pathToApp;
  });

  return function buildAsync(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
})();

let configureIOSShellAppAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (args, manifest) {
    const expoSourcePath = '../ios';
    let { privateConfigFile } = args;

    let privateConfig;
    if (privateConfigFile) {
      let privateConfigContents = yield _fs.default.promise.readFile(privateConfigFile, 'utf8');
      privateConfig = JSON.parse(privateConfigContents);
    }

    // make sure we have all the required info
    validateConfigArguments(manifest, args, args.archivePath);
    const context = (_StandaloneContext || _load_StandaloneContext()).default.createServiceContext(expoSourcePath, args.archivePath, manifest, privateConfig, args.configuration, args.url, args.releaseChannel, null);
    yield (_IosNSBundle || _load_IosNSBundle()).configureAsync(context);
  });

  return function configureIOSShellAppAsync(_x6, _x7) {
    return _ref3.apply(this, arguments);
  };
})();

let moveShellAppArchiveAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (args, manifest) {
    const { archivePath, output, type } = args;
    const archiveName = manifest.name.replace(/[^0-9a-z_\-\.]/gi, '_');
    const appReleasePath = _path.default.resolve(_path.default.join(`${archivePath}`, '..'));
    if (type === 'simulator') {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)(`mv Exponent.app ${archiveName}.app && tar -czvf ${output} ${archiveName}.app`, null, {
        stdio: 'inherit',
        cwd: appReleasePath,
        shell: true
      });
    } else if (type === 'archive') {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', ['Exponent.xcarchive', output], {
        stdio: 'inherit',
        cwd: `${archivePath}/../../../..`
      });
    }
    return;
  });

  return function moveShellAppArchiveAsync(_x8, _x9) {
    return _ref4.apply(this, arguments);
  };
})();

/**
*  @param url manifest url for shell experience
*  @param sdkVersion sdk to use when requesting the manifest
*  @param action
*    build - build a binary
*    configure - don't build anything, just configure the files in an existing .app bundle
*  @param type simulator or archive
*  @param releaseChannel channel to pull manifests from, default is 'default'
*  @param configuration Debug or Release, for type == simulator (default Release)
*  @param archivePath path to existing bundle, for action == configure
*  @param privateConfigFile path to a private config file containing, e.g., private api keys
*  @param verbose show all xcodebuild output (default false)
*  @param output specify the output path of built project (ie) /tmp/my-app-archive-build.xcarchive or /tmp/my-app-ios-build.tar.gz
*/


let createIOSShellAppAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (args) {
    args = validateArgs(args);

    if (args.action === 'build') {
      yield configureShellAppSecretsAsync(args, '../ios');
      yield buildAsync(args, '../ios', '../shellAppBase');
    } else if (args.action === 'configure') {
      let { url, sdkVersion } = args;
      let manifest = yield (0, (_ExponentTools || _load_ExponentTools()).getManifestAsync)(url, {
        'Exponent-SDK-Version': sdkVersion,
        'Exponent-Platform': 'ios',
        'Expo-Release-Channel': args.releaseChannel ? args.releaseChannel : 'default'
      });
      yield configureIOSShellAppAsync(args, manifest);
      if (args.output) {
        yield moveShellAppArchiveAsync(args, manifest);
      }
    }

    return;
  });

  return function createIOSShellAppAsync(_x10) {
    return _ref5.apply(this, arguments);
  };
})();

require('instapromise');

var _fs = _interopRequireDefault(require('fs'));

var _path = _interopRequireDefault(require('path'));

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosNSBundle;

function _load_IosNSBundle() {
  return _IosNSBundle = _interopRequireWildcard(require('./IosNSBundle'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function validateConfigArguments(manifest, cmdArgs, configFilePath) {
  if (!configFilePath) {
    throw new Error('No path to config files provided');
  }
  let bundleIdentifierFromManifest = manifest.ios ? manifest.ios.bundleIdentifier : null;
  if (!bundleIdentifierFromManifest) {
    throw new Error('No bundle identifier found in either the manifest or argv');
  }
  if (!manifest.name) {
    throw new Error('Manifest does not have a name');
  }

  if (!cmdArgs.privateConfigFile) {
    console.warn('Warning: No config file specified.');
  }
  return true;
}

function validateArgs(args) {
  args.type = args.type || 'archive';
  args.configuration = args.configuration || 'Release';
  args.verbose = args.verbose || false;

  switch (args.type) {
    case 'simulator':
      {
        if (args.configuration !== 'Debug' && args.configuration !== 'Release') {
          throw new Error(`Unsupported build configuration ${args.configuration}`);
        }
        break;
      }
    case 'archive':
      {
        if (args.configuration !== 'Release') {
          throw new Error('Release is the only supported configuration when archiving');
        }
        break;
      }
    default:
      {
        throw new Error(`Unsupported build type ${args.type}`);
      }
  }

  switch (args.action) {
    case 'configure':
      {
        if (!args.url) {
          throw new Error('Must run with `--url MANIFEST_URL`');
        }
        if (!args.sdkVersion) {
          throw new Error('Must run with `--sdkVersion SDK_VERSION`');
        }
        if (!args.archivePath) {
          throw new Error('Need to provide --archivePath <path to existing archive for configuration>');
        }
        break;
      }
    case 'build':
      {
        break;
      }
    default:
      {
        throw new Error(`Unsupported build action ${args.action}`);
      }
  }

  return args;
}

exports.createIOSShellAppAsync = createIOSShellAppAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosShellApp.js.map
