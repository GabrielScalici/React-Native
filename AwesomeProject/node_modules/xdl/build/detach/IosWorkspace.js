'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaths = exports.createDetachedAsync = exports.addDetachedConfigToExp = undefined;

let _getVersionedExpoKitConfigAsync = (() => {
  var _ref = _asyncToGenerator(function* (sdkVersion) {
    const versions = yield (_Versions || _load_Versions()).versionsAsync();
    let sdkVersionConfig = versions.sdkVersions[sdkVersion];
    if (!sdkVersionConfig) {
      if (process.env.EXPO_VIEW_DIR) {
        sdkVersionConfig = {};
      } else {
        throw new Error(`Unsupported SDK version: ${sdkVersion}`);
      }
    }
    const { iosVersion, iosExpoViewUrl } = sdkVersionConfig;
    const iosClientVersion = iosVersion ? iosVersion : versions.iosVersion;
    return {
      iosClientVersion,
      iosExpoViewUrl
    };
  });

  return function _getVersionedExpoKitConfigAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let _getOrCreateTemplateDirectoryAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, iosExpoViewUrl) {
    let expoTemplateDirectory;
    if (process.env.EXPO_VIEW_DIR) {
      // Only for testing
      expoTemplateDirectory = process.env.EXPO_VIEW_DIR;
    } else {
      expoTemplateDirectory = _path.default.join(projectRoot, 'temp-ios-directory');
      if (!(0, (_ExponentTools || _load_ExponentTools()).isDirectory)(expoTemplateDirectory)) {
        (_mkdirp || _load_mkdirp()).default.sync(expoTemplateDirectory);
        console.log('Downloading iOS code...');
        yield (_Api || _load_Api()).default.downloadAsync(iosExpoViewUrl, expoTemplateDirectory, {
          extract: true
        });
      }
    }
    return expoTemplateDirectory;
  });

  return function _getOrCreateTemplateDirectoryAsync(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

let _renameAndMoveProjectFilesAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectDirectory, projectName, exp) {
    // remove .gitignore, as this actually pertains to internal expo template management
    try {
      const gitIgnorePath = _path.default.join(projectDirectory, '.gitignore');
      if (_fs.default.existsSync(gitIgnorePath)) {
        (_rimraf || _load_rimraf()).default.sync(gitIgnorePath);
      }
    } catch (e) {}

    const filesToTransform = [_path.default.join('exponent-view-template.xcodeproj', 'project.pbxproj'), _path.default.join('exponent-view-template.xcworkspace', 'contents.xcworkspacedata'), _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme')];

    const bundleIdentifier = exp.ios && exp.ios.bundleIdentifier ? exp.ios.bundleIdentifier : '';

    yield Promise.all(filesToTransform.map(function (fileName) {
      return (0, (_ExponentTools || _load_ExponentTools()).transformFileContentsAsync)(_path.default.join(projectDirectory, fileName), function (fileString) {
        return fileString.replace(/com.getexponent.exponent-view-template/g, bundleIdentifier).replace(/exponent-view-template/g, projectName);
      });
    }));

    // order of this array matters
    const filesToMove = ['exponent-view-template', _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme'), 'exponent-view-template.xcodeproj', 'exponent-view-template.xcworkspace'];

    filesToMove.forEach((() => {
      var _ref4 = _asyncToGenerator(function* (fileName) {
        let destFileName = _path.default.join(_path.default.dirname(fileName), `${projectName}${_path.default.extname(fileName)}`);
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [_path.default.join(projectDirectory, fileName), _path.default.join(projectDirectory, destFileName)]);
      });

      return function (_x7) {
        return _ref4.apply(this, arguments);
      };
    })());

    return;
  });

  return function _renameAndMoveProjectFilesAsync(_x4, _x5, _x6) {
    return _ref3.apply(this, arguments);
  };
})();

// TODO: logic for when kernel sdk version is different from detached sdk version
// TODO: logic for when we're building a shell app (which may support many versions).


let _configureVersionsPlistAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (configFilePath, detachedSDKVersion, kernelSDKVersion) {
    yield (_IosPlist || _load_IosPlist()).modifyAsync(configFilePath, 'EXSDKVersions', function (versionConfig) {
      versionConfig.sdkVersions = [detachedSDKVersion];
      versionConfig.detachedNativeVersions = {
        shell: detachedSDKVersion,
        kernel: kernelSDKVersion
      };
      return versionConfig;
    });
  });

  return function _configureVersionsPlistAsync(_x8, _x9, _x10) {
    return _ref5.apply(this, arguments);
  };
})();

// TODO: logic for builds that support multiple RN versions.


let _renderPodfileFromTemplateAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (context, templatePodfilePath, sdkVersion, iosClientVersion) {
    const { iosProjectDirectory, projectName } = getPaths(context);
    let podfileSubstitutions = {
      TARGET_NAME: projectName,
      REACT_NATIVE_PATH: _path.default.relative(iosProjectDirectory, _path.default.join(context.data.projectPath, 'node_modules', 'react-native')),
      EXPOKIT_TAG: `ios/${iosClientVersion}`
    };
    if (process.env.EXPOKIT_TAG_IOS) {
      console.log(`EXPOKIT_TAG_IOS: Using custom ExpoKit iOS tag...`);
      podfileSubstitutions.EXPOKIT_TAG = process.env.EXPOKIT_TAG_IOS;
    } else if (process.env.EXPO_VIEW_DIR) {
      console.log('EXPO_VIEW_DIR: Using local ExpoKit source for iOS...');
      podfileSubstitutions.EXPOKIT_PATH = _path.default.relative(iosProjectDirectory, process.env.EXPO_VIEW_DIR);
    }
    yield (0, (_IosPodsTools || _load_IosPodsTools()).renderPodfileAsync)(templatePodfilePath, _path.default.join(iosProjectDirectory, 'Podfile'), podfileSubstitutions, sdkVersion);
  });

  return function _renderPodfileFromTemplateAsync(_x11, _x12, _x13, _x14) {
    return _ref6.apply(this, arguments);
  };
})();

let createDetachedAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (context) {
    // TODO: support both types of context
    if (context.type !== 'user') {
      throw new Error(`IosWorkspace only supports user standalone contexts`);
    }
    const sdkVersion = context.config.sdkVersion;
    const { iosProjectDirectory, projectName, supportingDirectory } = getPaths(context);
    const { iosClientVersion, iosExpoViewUrl } = yield _getVersionedExpoKitConfigAsync(sdkVersion);

    const expoTemplateDirectory = yield _getOrCreateTemplateDirectoryAsync(context.data.projectPath, iosExpoViewUrl);

    // copy downloaded template xcodeproj into the user's project.
    // HEY: if you need other paths into the extracted archive, be sure and include them
    // when the archive is generated in `ios/pipeline.js`
    console.log('Moving iOS project files...');
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(expoTemplateDirectory, 'exponent-view-template', 'ios'), iosProjectDirectory);

    console.log('Naming iOS project...');
    yield _renameAndMoveProjectFilesAsync(iosProjectDirectory, projectName, context.data.exp);

    console.log('Configuring iOS dependencies...');
    // this configuration must happen prior to build time because it affects which
    // native versions of RN we depend on.
    yield _configureVersionsPlistAsync(supportingDirectory, sdkVersion, sdkVersion);
    const templatePodfilePath = _path.default.join(expoTemplateDirectory, 'template-files', 'ios', 'ExpoKit-Podfile');
    yield _renderPodfileFromTemplateAsync(context, templatePodfilePath, sdkVersion, iosClientVersion);

    if (!process.env.EXPO_VIEW_DIR) {
      (0, (_ExponentTools || _load_ExponentTools()).rimrafDontThrow)(expoTemplateDirectory);
      yield (_IosPlist || _load_IosPlist()).cleanBackupAsync(supportingDirectory, 'EXSDKVersions', false);
    }

    return;
  });

  return function createDetachedAsync(_x15) {
    return _ref7.apply(this, arguments);
  };
})();

var _fs = _interopRequireDefault(require('fs'));

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosPodsTools;

function _load_IosPodsTools() {
  return _IosPodsTools = require('./IosPodsTools.js');
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('./IosPlist'));
}

var _Utils;

function _load_Utils() {
  return _Utils = _interopRequireWildcard(require('../Utils'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function addDetachedConfigToExp(exp, context) {
  if (context.type !== 'user') {
    console.warn(`Tried to modify exp for a non-user StandaloneContext, ignoring`);
    return;
  }
  if (!exp) {
    exp = {};
  }
  const { supportingDirectory } = getPaths(context);
  exp.ios.publishBundlePath = _path.default.relative(context.data.projectPath, _path.default.join(supportingDirectory, 'shell-app.bundle'));
  exp.ios.publishManifestPath = _path.default.relative(context.data.projectPath, _path.default.join(supportingDirectory, 'shell-app-manifest.json'));
  return exp;
}

function getPaths(context) {
  let iosProjectDirectory;
  let projectName;
  let supportingDirectory;
  let intermediatesDirectory;
  if (context.config && context.config.name) {
    let projectNameLabel = context.config.name;
    projectName = projectNameLabel.replace(/[^a-z0-9_\-]/gi, '-').toLowerCase();
  } else {
    throw new Error('Cannot configure an Expo project with no name.');
  }
  if (context.type === 'user') {
    iosProjectDirectory = _path.default.join(context.data.projectPath, 'ios');
    supportingDirectory = _path.default.join(iosProjectDirectory, projectName, 'Supporting');
    intermediatesDirectory = _path.default.join(iosProjectDirectory, 'ExpoKitIntermediates');
  } else if (context.type === 'service') {
    // compiled archive has a flat NSBundle
    supportingDirectory = context.data.archivePath;
    iosProjectDirectory = context.data.archivePath;
    intermediatesDirectory = _path.default.join(context.data.expoSourcePath, '..', 'shellAppIntermediates');
  } else {
    throw new Error(`Unsupported StandaloneContext type: ${context.type}`);
  }
  return {
    intermediatesDirectory,
    iosProjectDirectory,
    projectName,
    supportingDirectory
  };
}

exports.addDetachedConfigToExp = addDetachedConfigToExp;
exports.createDetachedAsync = createDetachedAsync;
exports.getPaths = getPaths;
//# sourceMappingURL=../__sourcemaps__/detach/IosWorkspace.js.map
